{"version":3,"sources":["shared/common/SignalRNotifications.ts","common/DurableHttpClient.ts","shared/common/Constants.ts","common/DurableEntitySet.ts","shared/CounterState.ts","App.tsx","index.tsx"],"names":["EntityStateChangedMessage","entityName","entityKey","version","stateDiff","isEntityDestructed","msg","FormatEntityId","BackendBaseUri","DurableHttpClient","_configFabric","NullLogger","instance","request","url","includes","config","this","accessTokenFactory","then","accessToken","headers","fakeUserNamePromise","fakeUserName","DefaultHttpClient","DurableEntitySet","_entityNameLowerCase","attachToAll","items","toLowerCase","makeObservable","observable","attachAllEntities","initSignalR","EntitySets","fetchAndApplyAllEntityStates","entityId","getEntityState","attachEntity","undefined","createEntity","signalName","argument","signalEntity","callEntity","metadata","updateEntityMetadata","initialState","entityNameLowerCase","existingEntity","state","makeAutoObservable","fetchAndApplyEntityState","uri","HttpClient","post","content","JSON","stringify","Promise","resolve","reject","response","correlationId","parse","SignalResultPromises","Config","logger","EntityStates","stateContainer","entityState","entitySet","push","i","length","splice","desiredVersion","retryCount","currentEntityState","get","Error","applyStateChangesFrom","entityAdded","addOrUpdateEntityState","catch","err","MaxRetryCount","setTimeout","RetryBaseIntervalMs","log","LogLevel","item","existingStateContainer","Information","GetEntityId","Trace","removeEntityState","entityDeleted","expectedVersion","rfc6902","responsePromise","errorMessage","result","SignalRConn","HubConnectionBuilder","withUrl","httpClient","build","on","entityStateChangedMessageHandler","entitySignalResponseHandler","onclose","reconnectToSignalR","start","SignalRReconnectIntervalInMs","incomingEntityState","diff","setup","l","console","counterState","title","countContainer","count","history","App","observer","className","onClick","map","n","React","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.159a133e.chunk.js","sourcesContent":["import * as rfc6902 from 'rfc6902';\r\n\r\nexport class EntityStateChangedMessage {\r\n    \r\n    entityName: string = '';\r\n    entityKey: string = '';\r\n    version: number = 0;\r\n    stateDiff: rfc6902.Operation[] = [];\r\n    isEntityDestructed: boolean = false;\r\n\r\n    static GetEntityId(msg: EntityStateChangedMessage): string {\r\n        return EntityStateChangedMessage.FormatEntityId(msg.entityName, msg.entityKey);\r\n    }\r\n\r\n    static FormatEntityId(entityName: string, entityKey: string): string {\r\n        return `@${entityName}@${entityKey}`;\r\n    }\r\n}\r\n\r\nexport class EntitySignalResponseMessage {\r\n\r\n    entityName: string = '';\r\n    entityKey: string = '';\r\n    correlationId: string = '';\r\n    result: any;\r\n    errorMessage: string = '';\r\n}","import { DefaultHttpClient, HttpRequest, HttpResponse, NullLogger } from '@aspnet/signalr';\r\n\r\nimport { IDurableEntitySetConfig } from './IDurableEntitySetConfig';\r\nimport { ClientPrincipalHeaderName } from '../shared/common/Constants';\r\n\r\nexport const BackendBaseUri = '/a/p/i';\r\n\r\n// Custom HttpClient implementation for the purposes of DurableEntitySet\r\nexport class DurableHttpClient extends DefaultHttpClient {\r\n\r\n    constructor(private _configFabric: () => IDurableEntitySetConfig) {\r\n        super(NullLogger.instance);\r\n    }\r\n\r\n    send(request: HttpRequest): Promise<HttpResponse> {\r\n\r\n        // Applying custom config settings, but only when calling our backend\r\n\r\n        if (request.url!.includes(BackendBaseUri)) {\r\n\r\n            const config = this._configFabric();\r\n\r\n            if (!!config.accessTokenFactory) {\r\n                return config.accessTokenFactory().then(accessToken => {\r\n\r\n                    request.headers = {}\r\n                    request.headers['Authorization'] = 'Bearer ' + accessToken;\r\n\r\n                    return super.send(request);\r\n                });\r\n            }\r\n\r\n            if (!!config.fakeUserNamePromise) {\r\n                return config.fakeUserNamePromise.then(fakeUserName => {\r\n\r\n                    if (!!fakeUserName) {\r\n                        request.headers = {}\r\n                        request.headers[ClientPrincipalHeaderName] = fakeUserName;\r\n                    }\r\n\r\n                    return super.send(request);\r\n                });\r\n            }\r\n        }\r\n\r\n        return super.send(request);\r\n    }\r\n}\r\n","\r\nexport const SignalRClientHandlerName = \"entity-state-changed\";\r\n\r\nexport const SignalRSignalResponseHandlerName = \"entity-signal-response\";\r\n\r\nexport const ClientPrincipalHeaderName = 'x-ms-client-principal-name';\r\n\r\nexport const UpdateMetadataServiceMethodName = \"$update-entity-internal-metadata\";\r\n","import { makeAutoObservable, makeObservable, observable } from 'mobx';\r\nimport { HubConnectionBuilder, HubConnection, NullLogger, LogLevel } from '@aspnet/signalr';\r\nimport * as rfc6902 from 'rfc6902';\r\n\r\nimport { ISetEntityMetadataRequest } from '../shared/common/ISetEntityMetadataRequest';\r\nimport { EntityStateChangedMessage, EntitySignalResponseMessage } from '../shared/common/SignalRNotifications';\r\nimport { SignalRClientHandlerName, SignalRSignalResponseHandlerName, UpdateMetadataServiceMethodName } from '../shared/common/Constants';\r\nimport { DurableEntityClientStateContainer } from '../shared/common/DurableEntityClientStateContainer';\r\nimport { IDurableEntitySetConfig } from './IDurableEntitySetConfig';\r\nimport { DurableHttpClient, BackendBaseUri } from './DurableHttpClient';\r\n\r\nexport type EntityStateWithKey = { entityKey: string };\r\n\r\n// Client-side container for Durable Entities\r\nexport class DurableEntitySet<TState extends object> {\r\n\r\n    // All attached entities will appear in this observable array\r\n    items: (TState & EntityStateWithKey)[] = [];\r\n    \r\n    constructor(private _entityNameLowerCase: string, attachToAll: boolean = true) {\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        this._entityNameLowerCase = this._entityNameLowerCase.toLowerCase();\r\n\r\n        makeObservable(this, { items: observable });\r\n        \r\n        if (attachToAll) {\r\n            this.attachAllEntities();\r\n        }\r\n    }\r\n\r\n    // Attach all entities of this type (that type you previously passed to ctor).\r\n    // Preloads all existing entities of this type and then automatically captures all newly created entities.\r\n    attachAllEntities(): Promise<void> {\r\n\r\n        DurableEntitySet.initSignalR();\r\n\r\n        // Registering ourselves as listeners for this type of entity\r\n        DurableEntitySet.EntitySets[this._entityNameLowerCase] = this.items;\r\n\r\n        // Loading all existing entities\r\n        return DurableEntitySet.fetchAndApplyAllEntityStates(this._entityNameLowerCase);\r\n    }\r\n\r\n    // Manually attach a single entity with specific key\r\n    attachEntity(entityKey: string): void {\r\n\r\n        const entityId = EntityStateChangedMessage.FormatEntityId(this._entityNameLowerCase, entityKey);\r\n\r\n        if (!!DurableEntitySet.getEntityState(entityId)) {\r\n            return;\r\n        }\r\n\r\n        // Registering ourselves as listeners for this particular entity\r\n        DurableEntitySet.EntitySets[entityId] = this.items;\r\n        \r\n        DurableEntitySet.attachEntity(this._entityNameLowerCase, entityKey, undefined as any);\r\n    }\r\n\r\n    // Creates (or fetches existing) an entity\r\n    createEntity(entityKey: string): void {\r\n\r\n        DurableEntitySet.createEntity(this._entityNameLowerCase, entityKey, undefined as any);\r\n    }\r\n\r\n    // Sends a signal to the given entity\r\n    signalEntity(entityKey: string, signalName: string, argument?: any): Promise<void> {\r\n\r\n        return DurableEntitySet.signalEntity(this._entityNameLowerCase, entityKey, signalName, argument);\r\n    }\r\n\r\n    // Sends a signal to the given entity and returns a promise with results\r\n    callEntity(entityKey: string, signalName: string, argument?: any): Promise<any> {\r\n\r\n        return DurableEntitySet.callEntity(this._entityNameLowerCase, entityKey, signalName, argument);\r\n    }\r\n\r\n    // Updates metadata of the given entity\r\n    updateEntityMetadata(entityKey: string, metadata: ISetEntityMetadataRequest): Promise<void> {\r\n\r\n        return DurableEntitySet.updateEntityMetadata(this._entityNameLowerCase, entityKey, metadata);\r\n    }\r\n\r\n    // Produces a single observable state instance for an existing entity\r\n    static attachEntity<TState extends object>(entityName: string, entityKey: string, initialState: TState): TState {\r\n\r\n        DurableEntitySet.initSignalR();\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        const entityNameLowerCase = entityName.toLowerCase();\r\n\r\n        const existingEntity = this.getEntityState(EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey));\r\n        if (!!existingEntity) {\r\n            // If it is a known entity, then just returning it\r\n            return existingEntity.state as TState;\r\n        }\r\n\r\n        if (!!initialState) {\r\n            makeAutoObservable(initialState);\r\n        }\r\n\r\n        // Try to asynchronously retrieve the state from server\r\n        this.fetchAndApplyEntityState(entityNameLowerCase, entityKey, 0, 0, initialState);\r\n\r\n        return initialState;\r\n    }\r\n\r\n    // Creates (or fetches existing) and produces a single observable state instance for a newly created entity\r\n    static createEntity<TState extends object>(entityName: string, entityKey: string, initialState: TState): TState {\r\n\r\n        // This empty request will create the entity, if it doesn't exist yet.\r\n        this.updateEntityMetadata(entityName, entityKey, {});\r\n\r\n        return this.attachEntity(entityName, entityKey, initialState);\r\n    }\r\n\r\n    // Sends a signal to the given entity\r\n    static signalEntity(entityName: string, entityKey: string, signalName: string, argument?: any): Promise<void> {\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        const entityNameLowerCase = entityName.toLowerCase();\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}/${entityKey}/${signalName}`;\r\n        return this.HttpClient.post(uri, { content: JSON.stringify(argument) }).then();\r\n    }\r\n\r\n    // Sends a signal to the given entity and returns a promise with results\r\n    static callEntity(entityName: string, entityKey: string, signalName: string, argument?: any): Promise<any> {\r\n\r\n        // Inside Durable Functions entity names are always lower-case, so we need to convert\r\n        const entityNameLowerCase = entityName.toLowerCase();\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}/${entityKey}/${signalName}`;\r\n\r\n        return new Promise<any>((resolve, reject) => {\r\n\r\n            this.HttpClient.post(uri, { content: JSON.stringify(argument) }).then(response => {\r\n\r\n                const correlationId: string = JSON.parse(response.content as string).correlationId;\r\n                this.SignalResultPromises[correlationId] = { resolve, reject };\r\n\r\n            }, reject);\r\n        });\r\n    }\r\n\r\n    // Updates metadata of the given entity\r\n    static updateEntityMetadata(entityName: string, entityKey: string, metadata: ISetEntityMetadataRequest): Promise<void> {\r\n\r\n        return this.signalEntity(entityName, entityKey, UpdateMetadataServiceMethodName, metadata);\r\n    }\r\n\r\n    // Optionally setup with these optional settings\r\n    static setup(config: IDurableEntitySetConfig): void {\r\n        this.Config = config;\r\n        if (!this.Config.logger) {\r\n            this.Config.logger = NullLogger.instance;\r\n        }\r\n    }\r\n\r\n    private static Config: IDurableEntitySetConfig = { logger: NullLogger.instance };\r\n    private static HttpClient: DurableHttpClient = new DurableHttpClient(() => DurableEntitySet.Config);\r\n    private static EntitySets: { [entityName: string]: EntityStateWithKey[] } = {};\r\n    private static SignalResultPromises: { [correlationId: string]: { resolve: (res: any) => void, reject: (err: Error) => void } } = {};\r\n\r\n    private static SignalRConn: HubConnection;\r\n\r\n    private static readonly SignalRReconnectIntervalInMs = 5000;\r\n    private static readonly MaxRetryCount = 6;\r\n    private static readonly RetryBaseIntervalMs = 500;\r\n    \r\n\r\n    private static EntityStates: { [entityId: string]: DurableEntityClientStateContainer } = {};\r\n\r\n    private static getEntityState(entityId: string): DurableEntityClientStateContainer {\r\n        return this.EntityStates[entityId];\r\n    }\r\n\r\n    private static addOrUpdateEntityState(entityId: string, stateContainer: DurableEntityClientStateContainer): void {\r\n        this.EntityStates[entityId] = stateContainer;\r\n    }\r\n\r\n    private static removeEntityState(entityId: string): void {\r\n        delete this.EntityStates[entityId];\r\n    }\r\n\r\n    private static entityAdded(entityNameLowerCase: string, entityKey: string, entityState: EntityStateWithKey) {\r\n\r\n        const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\r\n\r\n        // Searching for entitySet either for this particular entity or for this type of entity\r\n        var entitySet = this.EntitySets[entityId];\r\n        if (!entitySet) {\r\n            entitySet = this.EntitySets[entityNameLowerCase];\r\n        } else {\r\n            delete this.EntitySets[entityId];\r\n        }\r\n\r\n        if (!entitySet) {\r\n            return;\r\n        }\r\n\r\n        // Adding the entityKey property to the state object, to allow binding commands\r\n        entityState.entityKey = entityKey;\r\n        entitySet.push(entityState);\r\n    }\r\n\r\n    private static entityDeleted(entityNameLowerCase: string, entityKey: string) {\r\n\r\n        const entitySet = this.EntitySets[entityNameLowerCase];\r\n        if (!entitySet) {\r\n            return;\r\n        }\r\n\r\n        for (var i = 0; i < entitySet.length; i++) {\r\n\r\n            if (entitySet[i].entityKey === entityKey) {\r\n                entitySet.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static fetchAndApplyEntityState(entityNameLowerCase: string, entityKey: string, desiredVersion: number, retryCount: number, currentEntityState: any = null): void {\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}/${entityKey}`;\r\n        this.HttpClient.get(uri).then(response => {\r\n\r\n            const stateContainer = JSON.parse(response.content as string) as DurableEntityClientStateContainer;\r\n            const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\r\n\r\n            if (!!desiredVersion && (stateContainer.version < desiredVersion)) {\r\n                throw new Error(`Expected ${entityId} of version ${desiredVersion}, but got version ${stateContainer.version}`);\r\n            }\r\n\r\n            if (!currentEntityState) {\r\n\r\n                // If there is no existing state, then using the newly arrived state object\r\n                currentEntityState = stateContainer.state;\r\n                makeAutoObservable(currentEntityState);\r\n                \r\n            } else {\r\n\r\n                // Otherwise applying the change to the existing object, so that UI is re-rendered\r\n                this.applyStateChangesFrom(currentEntityState, stateContainer.state);\r\n            }\r\n\r\n            if (!this.getEntityState(entityId)) {\r\n                \r\n                // Adding the newly-arrived state into collections, if any\r\n                this.entityAdded(entityNameLowerCase, entityKey, currentEntityState);\r\n            }\r\n\r\n            // (Re)registering this entity\r\n            this.addOrUpdateEntityState(entityId, { state: currentEntityState, version: stateContainer.version });\r\n\r\n        }).catch(err => {\r\n\r\n            if (retryCount < this.MaxRetryCount) {\r\n\r\n                // Retrying\r\n                retryCount++;\r\n                setTimeout(() => {\r\n\r\n                    this.fetchAndApplyEntityState(entityNameLowerCase, entityKey, desiredVersion, retryCount, currentEntityState);\r\n\r\n                }, retryCount * this.RetryBaseIntervalMs);\r\n                \r\n            } else {\r\n\r\n                this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to fetch entity state: ${err}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    private static fetchAndApplyAllEntityStates(entityNameLowerCase: string): Promise<void> {\r\n\r\n        const uri = `${BackendBaseUri}/entities/${entityNameLowerCase}`;\r\n        return this.HttpClient.get(uri).then(response => {\r\n\r\n            for (var item of JSON.parse(response.content as string)) {\r\n\r\n                const entityKey = item.entityKey;\r\n                const entityId = EntityStateChangedMessage.FormatEntityId(entityNameLowerCase, entityKey);\r\n                const stateContainer = item as DurableEntityClientStateContainer;\r\n\r\n                const existingStateContainer = this.getEntityState(entityId);\r\n                if (!existingStateContainer) {\r\n\r\n                    makeAutoObservable(stateContainer.state);\r\n                    this.addOrUpdateEntityState(entityId, stateContainer);\r\n\r\n                    // Adding the newly-arrived state into collections, if any\r\n                    this.entityAdded(entityNameLowerCase, entityKey, stateContainer.state as any);\r\n                    \r\n\r\n                } else if (existingStateContainer.version < stateContainer.version) {\r\n\r\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId}, local version ${existingStateContainer.version}, remote version ${stateContainer.version}. State was updated.`);\r\n\r\n                    // Otherwise applying the change to the existing object, so that UI is re-rendered\r\n                    this.applyStateChangesFrom(existingStateContainer.state, stateContainer.state);\r\n                    existingStateContainer.version = stateContainer.version;\r\n\r\n                } else {\r\n\r\n                    this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: ${entityId} is already known and is up to date. Skipping.`);\r\n                }\r\n            }\r\n\r\n        }).catch(err => {\r\n            this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to fetch entity states: ${err}`);\r\n        });\r\n    }\r\n\r\n    private static entityStateChangedMessageHandler(msg: EntityStateChangedMessage): void {\r\n\r\n        const entityId = EntityStateChangedMessage.GetEntityId(msg);\r\n\r\n        this.Config.logger!.log(LogLevel.Trace, `DurableEntitySet: ${entityId} changed to version ${msg.version}`);\r\n\r\n        const existingStateContainer = this.getEntityState(entityId);\r\n        if (msg.isEntityDestructed) {\r\n\r\n            this.removeEntityState(entityId);\r\n\r\n            this.entityDeleted(msg.entityName, msg.entityKey);\r\n\r\n        } else if (!existingStateContainer) {\r\n\r\n            // If anybody is attached to this entity or this type of entity\r\n            if (!!this.EntitySets[entityId] || !!this.EntitySets[msg.entityName]) {\r\n                \r\n                // This entity is not known to us yet, so just trying to fetch its state from server\r\n                setTimeout(() => this.fetchAndApplyEntityState(msg.entityName, msg.entityKey, msg.version, 0), this.RetryBaseIntervalMs);\r\n            }\r\n           \r\n        } else {\r\n\r\n            const expectedVersion = existingStateContainer.version + 1;\r\n            if (msg.version > expectedVersion) {\r\n                \r\n                // Missed some updates, so now need to reload the state from server\r\n                this.fetchAndApplyEntityState(msg.entityName, msg.entityKey, msg.version, 0, existingStateContainer.state);\r\n\r\n            } else if (msg.version === expectedVersion) {\r\n\r\n                // Applying the change\r\n                rfc6902.applyPatch(existingStateContainer.state, msg.stateDiff);\r\n                existingStateContainer.version = msg.version;\r\n            }            \r\n        }\r\n    }\r\n\r\n    private static entitySignalResponseHandler(msg: EntitySignalResponseMessage): void {\r\n\r\n        const responsePromise = this.SignalResultPromises[msg.correlationId];\r\n        if (!responsePromise) {\r\n            return;\r\n        }\r\n\r\n        if (!msg.errorMessage) {\r\n            responsePromise.resolve(msg.result);\r\n        } else {\r\n            responsePromise.reject(new Error(msg.errorMessage));\r\n        }\r\n\r\n        delete this.SignalResultPromises[msg.correlationId];\r\n    }\r\n\r\n    private static initSignalR(): void {\r\n\r\n        if (!!this.SignalRConn) {\r\n            return;\r\n        }\r\n\r\n        // Configuring SignalR\r\n        this.SignalRConn = new HubConnectionBuilder()\r\n            .withUrl(`${BackendBaseUri}`, { httpClient: this.HttpClient, logger: this.Config.logger })\r\n            .build();\r\n\r\n        // Mounting event handlers\r\n        this.SignalRConn.on(SignalRClientHandlerName, msg => this.entityStateChangedMessageHandler(msg));\r\n        this.SignalRConn.on(SignalRSignalResponseHandlerName, msg => this.entitySignalResponseHandler(msg));\r\n\r\n        // Background reconnects are essential here. That's because in 'Default' or 'Classic' service mode\r\n        // clients get forcibly disconnected, when your backend restarts.\r\n        this.SignalRConn.onclose(() => this.reconnectToSignalR());\r\n\r\n        // Establishing SignalR connection\r\n        this.SignalRConn.start().then(\r\n            () => {\r\n                this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: successfully connected to SignalR`);\r\n            }, err => {\r\n                this.Config.logger!.log(LogLevel.Error, `DurableEntitySet: failed to connect to SignalR: ${err}`);\r\n            });\r\n    }\r\n\r\n    private static reconnectToSignalR() {\r\n\r\n        this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: reconnecting to SignalR...`);\r\n        this.SignalRConn.start().then(() => {\r\n            this.Config.logger!.log(LogLevel.Information, `DurableEntitySet: reconnected to SignalR`);\r\n        }, () => {\r\n            setTimeout(() => this.reconnectToSignalR(), this.SignalRReconnectIntervalInMs);\r\n        });\r\n    }\r\n\r\n    // Applies incoming changes to an existing observable object so, that UI is re-rendered\r\n    private static applyStateChangesFrom(currentEntityState: any, incomingEntityState: any): void {\r\n\r\n        // Need to preserve the entityKey field, if it is set\r\n        incomingEntityState.entityKey = currentEntityState.entityKey;\r\n\r\n        const diff = rfc6902.createPatch(currentEntityState, incomingEntityState);\r\n        rfc6902.applyPatch(currentEntityState, diff);\r\n    }\r\n}","\r\n// Sample entity state\r\nexport class CounterState\r\n{\r\n    title: string = '';\r\n\r\n    countContainer = {\r\n        count: 0\r\n    }\r\n\r\n    history: number[] = [];\r\n}","import React from 'react';\r\nimport { observer } from 'mobx-react';\r\n\r\nimport { DurableEntitySet } from './common/DurableEntitySet';\r\nimport { CounterState } from './shared/CounterState';\r\n\r\n// Optional setup\r\nDurableEntitySet.setup({\r\n\r\n    // Setup with some fake user name. This is for testing purposes only.\r\n    // When deployed to Azure with EasyAuth configured, this name will be replaced with your real user name.\r\n    fakeUserNamePromise: Promise.resolve('test-anonymous-user'),\r\n\r\n    logger: { log: (l, msg: string) => console.log(msg) }\r\n});\r\n\r\nconst entityName = 'CounterEntity';\r\nconst entityKey = 'my-counter';\r\n\r\n// Creating a single CounterEntity and binding to its state\r\nconst counterState = DurableEntitySet.createEntity(entityName, entityKey, new CounterState());\r\n\r\n// Rendering that entity state\r\nexport const App = observer(\r\n    class App extends React.Component {\r\n        render(): JSX.Element {\r\n            return (<>\r\n                <div className=\"counter-div\">\r\n                    <h3> Title: '{counterState.title}', count: {counterState.countContainer?.count}</h3>\r\n                    <button onClick={() => DurableEntitySet.signalEntity(entityName, entityKey, 'add', 1)}>\r\n                        Increment\r\n                    </button>\r\n                    <button onClick={() => DurableEntitySet.signalEntity(entityName, entityKey, 'substract', 1)}>\r\n                        Decrement\r\n                    </button>\r\n                </div>\r\n                <h4>{counterState.history.length ? 'History (last 10 values):' : ''}</h4>\r\n                <ul>\r\n                    {counterState.history.map(n => (<li>{n}</li>))}\r\n                </ul>\r\n            </>);\r\n        }\r\n    }\r\n);\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport { App } from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n"],"sourceRoot":""}